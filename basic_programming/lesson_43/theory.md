## Complexity (вычислительная сложность)

Понятие Complexity (вычислительная сложность), позволяет оценить эффективность алгоритмических решений. 
Простым языком можно сказать, что вычислительная сложность говорит, пропорционально какой функции растет 
колличество действий при обработке множества элементов, если увеличивать колличество элементов этого 
множества.

Для описания вычислительной сложности используется т. н. "Big O notation". 
Например, запись O(n), говорит о линейной сложности алгоритма. 
А O(log(n)), характеризует логарифмическую сложность.


## Итератор 

Если объект инкапсулирует внутри себя какое-то множество элементов, и есть необходимость перебрать 
все элементы этого множества, то с этим может возникнуть проблема. Если для передачи этого множества 
создать геттер, то возвращая ссылку, мы по сути даем небезопасный доступ к множеству за пределами 
объекта. 
Если возвращать копию множества, то это может повлиять на производительность. 

Для решения этой проблемы существует паттерн "Итератор". 

Суть паттерна это создать сторонний объект, который знает как "перебирать" (итерировать) множество 
элементов инкапсулированных в исходном объекте. 
Объект итератор должен иметь две функциональности: 
1) знать как определить есть ли следующий элемент; 
2) вернуть текущий элемент и перейти к следующему.

В Java существует интерфейс Iterator<T> с двумя абстрактными методами: boolean hasNext(), 
возвращающий true, если еще есть элементы, и false если дошли до конца множества, и T next() 
возвращающий текущий элемент, и переводящий "указатель" к следующему элементу. 
В интерфейсе Iterator существует еще дополнительный дефолтный метод void remove(), 
который имеет пустое тело. Но если нам надо реализовать функциональность корректного удаления 
текущего элемента в процессе итерирования, то метод remove надо переопределить.

Класс инкапсулирущий множество, которое надо итерировать, может имплементировать интерфейс Iterable<T>,
у которого только один абстрактный метод Iterator<T> iterator(), возвращающий итератор для объектов 
данного класса.

Для Iterable объектов можно использовать цикл for-each. Его сигнатура вот такая: 
for(T e: "set of T"){ 
do something}; 

В теле этого цикла переменная "e" принимает поочередно значение каждого элемента
(T e: "set of T"){ 
do something}; 
В теле этого цикла переменная "e" принимает поочередно значение каждого элемента из итерируемого множества. 
В цикле for-each нельзя модифицировать итерируемое множество.









Java Collection Framework (JCF) - множество классов и интерфейсов которые реализуют наиболее часто 
используемые структуры данных. JCF состоит из двух больших подразделов: Map и Collection. 
Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. 
Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. 
Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. 
И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, 
т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, 
помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. 
апример вставка по индексу, удаление по индексу, получение элемента по индексу, поиск индекса заданного 
аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности 
интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив 
полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. 
И теперь ждем когда заполнится новый массив. И т. д.
Т. е. простым языком ArrayList представляет из себя "резиновый массив".

