# Символы в памяти компьютера

## История вопроса
**Факт №1:**
компьютеры понимают только два числа - 0 и 1.

Поэтому любой набор данных в оперативной памяти компьютера храниться в виде **двоичного числа**
(комбинация из 0 и 1).
Это относится и к **строкам**, которые состоят из **символов** (буквы, цифры, знаки препинания и т.д.).

Когда символ сохраняется в памяти, он сначала преобразуется в цифровой код.
И затем этот цифровой код сохраняется в памяти как двоичное число.
За прошедшие годы для представления символов в памяти компьютера были разработаны различные схемы кодирования.
Исторически самой важной из этих схем кодирования является схема кодирования
**ASCII** (American Standard Code for Information Interchange – американский стандартный код обмена информацией).

**Таблица символов ASCII**  
ASCII представляет собой набор из 128 цифровых кодов, которые обозначают английские буквы,
различные знаки препинания и другие символы.

Например, код ASCII для прописной английской буквы «А» (латинской) равняется 65.
Когда на компьютерной клавиатуре вы набираете букву «А» в верхнем регистре,
в памяти сохраняется число 65 (как двоичное число, разумеется).
Код ASCII для английской «В» в верхнем регистре равняется 66, для «С» в верхнем регистре – 67 и т. д.
На один символ в ASCII отводится ровно 7 бит.

Набор символов ASCII был разработан в начале 1960-х годов и в конечном счете принят
почти всеми производителями компьютеров. Однако схема кодирования ASCII имеет ограничения,
потому что она определяет коды только для 128 символов. Для того чтобы это исправить,
в начале 1990-х годов был разработан набор символов Юникода (Unicode).
Это широкая схема кодирования, совместимая с ASCII, которая может также представлять символы многих языков мира.
Сегодня Юникод быстро становится стандартным набором символов, используемым в компьютерной индустрии.

**Таблица символов Unicode**  
Таблица символов Юникод представляет собой набор цифровых символов, которые включают в себя
знаки почти всех письменных языков мира. Стандарт предложен в 1991 году некоммерческой организацией
«Консорциум Юникода». Применение этого стандарта позволяет закодировать очень большое число символов
из разных систем письменности: в документах, закодированных по стандарту Юникод, могут соседствовать
китайские иероглифы, математические символы, буквы греческого алфавита, латиницы и кириллицы, символы
музыкальной нотной нотации.

Стандарт состоит из двух основных частей: универсального набора символов и семейства кодировок
(Unicode transformation format, UTF). Универсальный набор символов перечисляет допустимые по стандарту Юникод
символы и присваивает каждому символу код в виде неотрицательного целого числа.
Семейство кодировок определяет способы преобразования кодов символов для хранения на компьютере и передачи.

В Юникод все время добавляются новые символы, а сам размер этой таблицы не ограничен и будет только расти,
поэтому сейчас при хранении в памяти одного юникод-символа может потребоваться от 1 до 8 байт.
Отсутствие ограничений привело к тому, что стали появляться символы на все случаи жизни.

Примечание 1. Официальный сайт таблицы символов Unicode: https://home.unicode.org
Примечание 2. Юникод — это не кодировка. Это именно таблица символов.

То, как символы с соответствующими кодами будут храниться в памяти компьютера, зависит от конкретной кодировки,
базирующейся на Юникоде, например UTF-8.
Про отличие таблицы символов Unicode от кодировки UTF-8 можно почитать тут:
https://developer.roman.grinyov.name/blog/104

Примечание 3. Первые 128 кодов таблицы символов Unicode совпадают с ASCII.

## Работа с символами в Java
Следующий символ потока ввода можно прочитать как напрямую из потока ввода:

int code = System.in.read();

так и с использованием класса BufferedReader или Scanner:

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int code = br.read();
Метод read() возвращает int, а не char. Для работы с кодом как с символом потребуется явное преобразование:

int code = System.in.read();
char character = (char) code;
Задать значение переменной типа char можно следующим способом:

char a = 'A'; // Переменная а будет содержать латинскую букву А.
char a = 65;
// Переменная а будет содержать латинскую букву А. Ее код как раз 65.
char a = 0x41;
// Переменная а будет содержать латинскую букву А.
// Ее код как раз 65, что равно 41 в шестнадцатеричной системе.
char a = 0x0041; // Два лишних нуля ничего не меняют.
char a ='\u0041'; // Указание на код Unicode, можно внутри строки
Обратите внимание: один символ — объект типа char — записывается в одинарных кавычках ('),
а несколько символов — строка — в двойных (").

## Классы, объекты и методы на примере класса String

**Объект (Object)** - это нужная/полезная для смысла жизни "сущность", например:
предмет, человек или животное, организация, деталь, строка и т.д.

Совокупность однородных, схожих по конструкции объектов формирует **Класс (Class)**.
Пример: класс Автомобили, класс Млекопитающие, класс Звезды, класс Строки и т.д.

Сегодня нас интересукт класс **String (стока)** - этот класс объединяет в себе объекты, которые
состоят из последовательностей ASCII - символов, то есть из строк.

# Класс String
Содержимое строки задается в двойных кавычках.
String st = "Это строка"; // строчечные константы "одеваем в шубу" из кавычек

Сложить две строки в Java довольно просто, воспользовавшись оператором +.
Java позволяет складывать друг с другом и переменные, и строковые литералы:
String day = "День";
String and = "и";
String night = "Ночь";
String dayAndNight = day + " " + and + " " + night;

## Методы класса String:

### Основные методы класса String
Основные операции со строками раскрываются через методы класса String.

valueOf(): преобразует объект в строковый вид, например число 527 => "527" это строка
charAt(): возвращает символ строки по индексу, пример chatAt("Java", 2) => v
equals(): сравнивает строки с учетом регистра, выполняет сравнение двух строк
equalsIgnoreCase(): сравнивает строки без учета регистра, пример Leonid = leonid эти строки будут равны
indexOf(): находит индекс первого вхождения подстроки в строку, indexOf(J, "Java") => 0
startsWith(): определяет, начинается ли строка с подстроки, см. practice, 
результат будет true или false (тип boolean - логический тип)
endsWith(): определяет, заканчивается ли строка на определенную подстроку, см. practice,
результат будет true или false (тип boolean - логический тип)
replace(): заменяет в строке одну подстроку на другую, пример: может поменять все буквы "a" на буквы "o"
trim(): удаляет начальные и конечные пробелы в строке
substring(): возвращает подстроку, начиная с определенного индекса до конца или до определенного индекса, 
см. practice
toLowerCase(): переводит все символы строки в нижний регистр
toUpperCase(): переводит все символы строки в верхний регистр

### Практикум
Дана строка "I like Java! Java is the best way to earn good salary in IT.".
1. Распечатать последний символ строки. Используем метод String.charAt().
2. Найти позицию подстроки “Java” в строке “I like Java!”.
3. Проверить, содержит ли заданная строка подстроку “Java”. Используем метод String.contains().
4. Заменить все символы “а” на “о”.
5. Преобразуйте строку к верхнему регистру.
6. Преобразуйте строку к нижнему регистру.
7. Вырезать строку Java c помощью метода String.substring().
8. Проверить, заканчивается ли ваша строка подстрокой “!!!”. Используем метод String.endsWith(),
   привыкаем к типу boolean.
9. Проверить, начинается ли ваша строка подстрокой “I like”. Используем метод String.startsWith().


### Методы
**методы** содержат  набор операторов, которые выполняют определенные,
необходимые нам действия.

## Синтаксис
задание/объявление методов в программе выглядит следующим образом:

- **вариант 1** - метод возвращает занчение с указанным типом:
  `public static тип_возвращяемого_значения имяМетода(int параметр1, String параметр2) {
  команды;
  return возвращаемое значение;
  }`

- **вариант 2** - метод просто что-то делает, ничего не возвращает:
  `public static void имяМетода(int параметр1, String параметр2) {
  команды;
  return;
  }`

Заголовок метода - это его **СИГНАТУРА**.

Модификаторы и параметры необязательны, то есть могут отсутствовать.

По умолчанию главный класс любой программы на Java содержит метод main,
который служит точкой входа в программу:

public static void main(String[] args) {
System.out.println("Hello world!");
}

- Ключевые слова public и static являются модификаторами, которые управляют доступом и
  видимостью метода.
- Далее идет тип возвращаемого методом значения.
- Ключевое слово **void** указывает на то, что метод ничего не возвращает,
  а просто что-то делает.
- Затем идут название метода - main и в скобках параметры метода - String[] args.
- В фигурные скобки заключено тело метода - все действия, которые он выполняет.

Вызов метода осуществляется в форме:
имя_метода(аргументы); // это строчка в програме внутри main или другого метода
(да, методы можно вызывать друг из друга!)

После имени метода указываются скобки, в которых перечисляются **аргументы**
(значения) для параметров метода.

Одно из **важных преимуществ методов** заключается в том, что  мы
можем вынести некоторые общие действия в отдельный метод(ы) и затем
вызывать многократно их в различных местах программы.